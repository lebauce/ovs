#! /usr/bin/python

import sys
import os.path
import re
from optparse import OptionParser

OFP_ACTION_ALIGN = 8

# Map from OpenFlow version number to version ID used in ofp_header.
version_map = {"1.0": 0x01,
               "1.1": 0x02,
               "1.2": 0x03,
               "1.3": 0x04,
               "1.4": 0x05,
               "1.5": 0x06}
version_reverse_map = dict((v, k) for (k, v) in version_map.items())

# Map from vendor name to the length of the action header.
vendor_map = {"OF": (0x00000000,  4),
              "ONF": (0x4f4e4600, 10),
              "NX": (0x00002320, 10)}

# Basic types used in action arguments.
types = {}
types['uint8_t'] =  {"size": 1, "align": 1, "ntoh": None,     "hton": None}
types['ovs_be16'] = {"size": 2, "align": 2, "ntoh": "ntohs",  "hton": "htons"}
types['ovs_be32'] = {"size": 4, "align": 4, "ntoh": "ntohl",  "hton": "htonl"}
types['ovs_be64'] = {"size": 8, "align": 8, "ntoh": "ntohll", "hton": "htonll"}
types['uint16_t'] = {"size": 2, "align": 2, "ntoh": None,     "hton": None}
types['uint32_t'] = {"size": 4, "align": 4, "ntoh": None,     "hton": None}
types['uint64_t'] = {"size": 8, "align": 8, "ntoh": None,     "hton": None}

line = ""

def round_up(x, y):
    return int((x + (y - 1)) / y) * y

def open_file(fn):
    global file_name
    global input_file
    global line_number
    file_name = fn
    input_file = open(file_name)
    line_number = 0

def get_line():
    global input_file
    global line
    global line_number
    line = input_file.readline()
    line_number += 1
    if line == "":
        fatal("unexpected end of input")
    return line

n_errors = 0
def error(msg):
    global n_errors
    sys.stderr.write("%s:%d: %s\n" % (file_name, line_number, msg))
    n_errors += 1

def fatal(msg):
    error(msg)
    sys.exit(1)

def usage():
    argv0 = os.path.basename(sys.argv[0])
    print('''\
%(argv0)s, for extracting OpenFlow action data
usage: %(argv0)s OFP_ACTIONS.C [--prototypes | --definitions]

This program reads ofp-actions.c to obtain information about OpenFlow
actions.  With --prototypes, it outputs on stdout a set of prototypes to
#include early in ofp-actions.c.  With --definitions, it outputs on stdout
a set of definitions to #include late in ofp-actions.c

OFP_ACTIONS.C should point to lib/ofp-actions.c.\
''' % {"argv0": argv0})
    sys.exit(0)

def extract_ofp_actions(fn):
    arg_structs = set()
    comments = []
    names = []
    domain = {}
    for code, size in vendor_map.values():
        domain[code] = {}
    enums = {}

    n_errors = 0

    open_file(fn)

    while True:
        get_line()
        if re.match('enum ofp_raw_action_type {', line):
            break

    while True:
        get_line()
        if line.startswith('/*') or not line or line.isspace():
            continue
        elif re.match('}', line):
            break

        if not line.lstrip().startswith('/*'):
            fatal("unexpected syntax between actions")

        comment = line.lstrip()[2:].strip()
        while not comment.endswith('*/'):
            get_line()
            if line.startswith('/*') or not line or line.isspace():
                fatal("unexpected syntax within action")
            comment += ' %s' % line.lstrip('* \t').rstrip(' \t\r\n')
        comment = re.sub('\[[^]]*\]', '', comment)
        comment = comment[:-2].rstrip()

        m = re.match('([^:]+):\s+(.*)$', comment)
        if not m:
            fatal("unexpected syntax between actions")

        dsts = m.group(1)
        argtypes = m.group(2).strip().replace('.', '', 1)

        if 'VLMFF' in argtypes:
            arg_vl_mff_map = True
        else:
            arg_vl_mff_map = False
        argtype = argtypes.replace('VLMFF', '', 1).rstrip()

        get_line()
        m = re.match(r'\s+(([A-Z]+)_RAW([0-9]*)_([A-Z0-9_]+)),?', line)
        if not m:
            fatal("syntax error expecting enum value")

        enum = m.group(1)
        if enum in names:
            fatal("%s specified twice" % enum)

        names.append(enum)

        for dst in dsts.split(', '):
            m = re.match(r'([A-Z]+)([0-9.]+)(\+|-[0-9.]+)?(?:\((\d+)\))(?: is deprecated \(([^)]+)\))?$', dst)
            if not m:
                fatal("%r: syntax error in destination" % dst)
            vendor_name = m.group(1)
            version1_name = m.group(2)
            version2_name = m.group(3)
            type_ = int(m.group(4))
            deprecation = m.group(5)

            if vendor_name not in vendor_map:
                fatal("%s: unknown vendor" % vendor_name)
            vendor = vendor_map[vendor_name][0]

            if version1_name not in version_map:
                fatal("%s: unknown OpenFlow version" % version1_name)
            v1 = version_map[version1_name]

            if version2_name is None:
                v2 = v1
            elif version2_name == "+":
                v2 = max(version_map.values())
            elif version2_name[1:] not in version_map:
                fatal("%s: unknown OpenFlow version" % version2_name[1:])
            else:
                v2 = version_map[version2_name[1:]]

            if v2 < v1:
                fatal("%s%s: %s precedes %s"
                      % (version1_name, version2_name,
                         version2_name, version1_name))

            for version in range(v1, v2 + 1):
                domain[vendor].setdefault(type_, {})
                if version in domain[vendor][type_]:
                    v = domain[vendor][type_][version]
                    msg = "%#x,%d in OF%s means both %s and %s" % (
                        vendor, type_, version_reverse_map[version],
                        v["enum"], enum)
                    error("%s: %s." % (dst, msg))
                    sys.stderr.write("%s:%d: %s: Here is the location "
                                     "of the previous definition.\n"
                                     % (v["file_name"], v["line_number"],
                                        dst))
                    n_errors += 1
                else:
                    header_len = vendor_map[vendor_name][1]

                    base_argtype = argtype.replace(', ..', '', 1)
                    if base_argtype in types:
                        arg_align = types[base_argtype]['align']
                        arg_len = types[base_argtype]['size']
                        arg_ofs = round_up(header_len, arg_align)
                        min_length = round_up(arg_ofs + arg_len,
                                              OFP_ACTION_ALIGN)
                    elif base_argtype == 'void':
                        min_length = round_up(header_len, OFP_ACTION_ALIGN)
                        arg_len = 0
                        arg_ofs = 0
                    elif re.match(r'struct [a-zA-Z0-9_]+$', base_argtype):
                        min_length = 'sizeof(%s)' % base_argtype
                        arg_structs.add(base_argtype)
                        arg_len = 0
                        arg_ofs = 0
                        # should also emit OFP_ACTION_ALIGN assertion
                    else:
                        fatal("bad argument type %s" % argtype)

                    ellipsis = argtype != base_argtype
                    if ellipsis:
                        max_length = '65536 - OFP_ACTION_ALIGN'
                    else:
                        max_length = min_length

                    info = {"enum": enum,                     # 0
                            "deprecation": deprecation,       # 1
                            "file_name": file_name,           # 2
                            "line_number": line_number,       # 3
                            "min_length": min_length,         # 4
                            "max_length": max_length,         # 5
                            "arg_ofs": arg_ofs,               # 6
                            "arg_len": arg_len,               # 7
                            "base_argtype": base_argtype,     # 8
                            "arg_vl_mff_map": arg_vl_mff_map, # 9
                            "version": version,               # 10
                            "type": type_}                    # 11
                    domain[vendor][type_][version] = info

                    enums.setdefault(enum, [])
                    enums[enum].append(info)

    input_file.close()

    if n_errors:
        sys.exit(1)

    return arg_structs, enums, domain


def generate_declaration(versions):
    need_ofp_version = False
    for v in versions:
        assert v["arg_len"] == versions[0]["arg_len"]
        assert v["base_argtype"] == versions[0]["base_argtype"]
        if (v["min_length"] != versions[0]["min_length"] or
            v["arg_ofs"] != versions[0]["arg_ofs"] or
            v["type"] != versions[0]["type"]):
            need_ofp_version = True
    base_argtype = versions[0]["base_argtype"]

    decl = "static inline "
    if base_argtype.startswith('struct'):
        decl += "%s *" % base_argtype
    else:
        decl += "void"
    decl += "\nput_%s(struct ofpbuf *openflow" % versions[0]["enum"].replace('_RAW', '', 1)
    if need_ofp_version:
        decl += ", enum ofp_version version"
    if base_argtype != 'void' and not base_argtype.startswith('struct'):
        decl += ", %s arg" % base_argtype
    decl += ")"
    return need_ofp_version, base_argtype, decl


def make_definitions(arg_structs, enums, domain):
    print("""\
/* Generated automatically; do not modify!     -*- buffer-read-only: t -*- */
""")

    print("/* Verify that structs used as actions are reasonable sizes. */")
    for s in sorted(arg_structs):
        print("BUILD_ASSERT_DECL(sizeof(%s) %% OFP_ACTION_ALIGN == 0);" % s)

    print("\nstatic struct ofpact_raw_instance all_raw_instances[] = {")
    for vendor in domain:
        for type_ in domain[vendor]:
            for version in domain[vendor][type_]:
                d = domain[vendor][type_][version]
                print("    { { 0x%08x, %2d, 0x%02x }, " % (
                    vendor, type_, version))
                print("      %s," % d["enum"])
                print("      HMAP_NODE_NULL_INITIALIZER,")
                print("      HMAP_NODE_NULL_INITIALIZER,")
                print("      %s," % d["min_length"])
                print("      %s," % d["max_length"])
                print("      %s," % d["arg_ofs"])
                print("      %s," % d["arg_len"])
                print("      \"%s\"," % re.sub('_RAW[0-9]*', '', d["enum"], 1))
                if d["deprecation"]:
                    print("      \"%s\"," % re.sub(r'(["\\])', r'\\\1', d["deprecation"]))
                else:
                    print("      NULL,")
                print("    },")
    print("};")

    for versions in enums.values():
        need_ofp_version, base_argtype, decl = generate_declaration(versions)
        decl += "{\n"
        decl += "    "
        if base_argtype.startswith('struct'):
            decl += "return "
        decl += "ofpact_put_raw(openflow, "
        if need_ofp_version:
            decl += "version"
        else:
            decl += "%s" % versions[0]["version"]
        decl += ", %s, " % versions[0]["enum"]
        if base_argtype.startswith('struct') or base_argtype == 'void':
            decl += "0"
        else:
            ntoh = types[base_argtype]['ntoh']
            if ntoh:
                decl += "%s(arg)" % ntoh
            else:
                decl += "arg"
        decl += ");\n"
        decl += "}"
        print(decl)
        print("")

    print("""\
static enum ofperr
ofpact_decode(const struct ofp_action_header *a, enum ofp_raw_action_type raw,
            enum ofp_version version, uint64_t arg,
            const struct vl_mff_map *vl_mff_map,
            uint64_t *tlv_bitmap, struct ofpbuf *out)
{
    switch (raw) {\
""")
    for versions in enums.values():
        enum = versions[0]["enum"]
        print("    case %s:" % enum)
        base_argtype = versions[0]["base_argtype"]
        arg_vl_mff_map = versions[0]["arg_vl_mff_map"]
        if base_argtype == 'void':
            print("        return decode_%s(out);" % enum)
        else:
            if base_argtype.startswith('struct'):
                arg = "ALIGNED_CAST(const %s *, a)" % base_argtype
            else:
                hton = types[base_argtype]['hton']
                if hton:
                    arg = "%s(arg)" % hton
                else:
                    arg = "arg"
            if arg_vl_mff_map:
                print("        return decode_%s(%s, version, vl_mff_map, tlv_bitmap, out);" % (enum, arg))
            else:
                print("        return decode_%s(%s, version, out);" % (enum, arg))
        print("")
    print("""\
    default:
        OVS_NOT_REACHED();
    }
}\
""")


def make_prototypes(arg_structs, enums, domain):
    print("""\
/* Generated automatically; do not modify!     -*- buffer-read-only: t -*- */
""")

    for versions in enums.values():
        need_ofp_version, base_argtype, decl = generate_declaration(versions)
        print(decl + ";")
        print("")

    for versions in enums.values():
        enum = versions[0]["enum"]
        prototype = "static enum ofperr decode_%s(" % enum
        base_argtype = versions[0]["base_argtype"]
        arg_vl_mff_map = versions[0]["arg_vl_mff_map"]
        if base_argtype != 'void':
            if base_argtype.startswith('struct'):
                prototype += "const %s *, enum ofp_version, " % base_argtype
            else:
                prototype += "%s, enum ofp_version, " % base_argtype
            if arg_vl_mff_map:
                prototype += 'const struct vl_mff_map *, uint64_t *, '
        prototype += "struct ofpbuf *);"
        print(prototype)

    print("""
static enum ofperr ofpact_decode(const struct ofp_action_header *,
                                enum ofp_raw_action_type raw,
                                enum ofp_version version,
                                uint64_t arg, const struct vl_mff_map *vl_mff_map,
                                uint64_t *tlv_bitmap, struct ofpbuf *out);
""")


# make_loxigen uses a header file generated using
# pahole -q -y nx_ libopenvswitch.a > nx-structs.h
# pahole -q -y ext_action_header libopenvswitch.a >> nx-structs.h
def make_loxigen(filename, arg_structs, enums, domain):
    c_defs = """
    typedef short ovs_be16;
    typedef int ovs_be32;
    typedef long long ovs_be64;
    typedef unsigned char uint8_t;
    """

    types_len = {
        "uint8_t": 1,
        "ovs_be16": 2,
        "ovs_be32": 4,
        "ovs_be64": 8
    }

    loxi_types = {
        "uint8_t": "uint8_t",
        "ovs_be16": "uint16_t",
        "ovs_be32": "uint32_t",
        "ovs_be64": "uint64_t"
    }

    from pycparser import c_parser, c_ast, parse_file

    class StructVisitor(c_ast.NodeVisitor):
        def __init__(self):
            c_ast.NodeVisitor.__init__(self)
            self.structs = {}

        def visit_Struct(self, struct):
            self.structs[struct.name] = struct.children()

    print("""// Copyright 2013, Big Switch Networks, Inc.
//
// LoxiGen is licensed under the Eclipse Public License, version 1.0 (EPL), with
// the following special exception:
//
// LOXI Exception
//
// As a special exception to the terms of the EPL, you may distribute libraries
// generated by LoxiGen (LoxiGen Libraries) under the terms of your choice, provided
// that copyright and licensing notices generated by LoxiGen are not altered or removed
// from the LoxiGen Libraries and the notice provided below is (i) included in
// the LoxiGen Libraries, if distributed in source code form and (ii) included in any
// documentation for the LoxiGen Libraries, if distributed in binary form.
//
// Notice: "Copyright 2013, Big Switch Networks, Inc. This library was generated by the LoxiGen Compiler."
//
// You may not use this file except in compliance with the EPL or LOXI Exception. You may obtain
// a copy of the EPL at:
//
// http://www.eclipse.org/legal/epl-v10.html
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// EPL for the specific language governing permissions and limitations
// under the EPL.

#version any
""")

    parser = c_parser.CParser()
    code = open(filename).read()
    ast = parser.parse(c_defs + code, filename)

    v = StructVisitor()
    v.visit(ast)

    vendor = vendor_map['NX'][0]
    for i, type_ in enumerate(domain[vendor]):
        versions = domain[vendor][type_].keys()
        d = domain[vendor][type_][versions[-1]]

        if d["enum"].startswith("OFPAT_RAW_"):
            continue

        if not d["enum"].startswith("NXAST_RAW_"):
            raise Exception("Invalid enum type '%s'" % (d["enum"]))

        name = d["enum"][10:].lower()

        attrs = []
        base_class = "of_action_nicira"
        base_argtype = d["base_argtype"]
        if d["base_argtype"].startswith("struct "):
            struct_name = base_argtype.split()[1]
            if struct_name not in v.structs:
                raise Exception("Unknown struct '%s'" % (struct_name,))

            for child in v.structs[struct_name][4:]:
                decl = child[1]
                attr_name = decl.name
                if isinstance(decl.type, c_ast.Union):
                    # Check that all enum values have the same type
                    type_name = decl.type.decls[0].type.type.names[0]
                    for member in decl.type.decls[1:]:
                        if member.type.type.names[0] != type_name:
                            raise Exception("All enum values should have the type '%s" % (type_name))
                    attrs.append("%s value" % (loxi_types[type_name],))
                elif attr_name.startswith("pad") or attr_name in ("zero", "zeros"):
                    if isinstance(decl.type, c_ast.ArrayDecl):
                        pad_size = int(decl.type.dim.value)
                    else:
                        type_name = decl.type.type.names[0]
                        pad_size = types_len[type_name]
                    attrs.append("pad(%d)" % (pad_size,))
                elif isinstance(decl.type, c_ast.ArrayDecl):
                    if isinstance(decl.type.type.type, c_ast.Struct):
                        attrs.append("list(%s_t) %s" % (decl.type.type.type.name, attr_name))
                    else:
                        elem_type = decl.type.type.type.names[0]
                        if elem_type != "uint8_t":
                            raise Exception("Only array of bytes are supported, got '%s'" % (elem_type,))
                        attrs.append("of_octets_t %s" % (attr_name,))
                else:
                    if isinstance(decl.type.type, c_ast.Struct):
                        if len(attrs) == 0:
                            base_class = "of_action_nx_" + decl.type.type.name[10:] # remove nx_action_
                        else:
                            attrs.append("%s_t %s" % (decl.type.type.name, attr_name))
                    else:
                        type_name = decl.type.type.names[0]
                        attrs.append("%s %s" % (loxi_types[type_name], attr_name))

        elif d["base_argtype"] == "void":
            pass
        else:
            attrs.append("%s value" % (base_argtype,))

        if i != 0:
            print("")
        print("struct of_action_nx_%s : %s {" % (name, base_class))
        print("    uint16_t type == 65535;");
        print("    uint16_t len;")
        print("    uint32_t experimenter == 0x2320;")
        print("    uint16_t subtype == %d;" % (type_,))
        for attr in attrs:
            print("    %s;" % (attr,))
        print("};")


if __name__ == '__main__':
    parser = OptionParser()
    parser.add_option("--prototypes", action="store_true", dest="prototypes")
    parser.add_option("--definitions", action="store_true", dest="definitions")
    parser.add_option("--loxigen", action="store_true", dest="loxigen")
    (options, args) = parser.parse_args()

    if len(args) < 1:
        sys.stderr.write("input file required\n")
        parser.print_usage()
        sys.exit(1)

    arg_structs, enums, domain = extract_ofp_actions(args[0])

    if options.prototypes:
        make_prototypes(arg_structs, enums, domain)
    elif options.definitions:
        make_definitions(arg_structs, enums, domain)
    elif options.loxigen:
        if len(args) < 2:
            sys.stderr.write("header file required\n")
            sys.exit(1)
        make_loxigen(args[1], arg_structs, enums, domain)
    else:
        parser.print_usage()
        sys.exit(1)
